<!DOCTYPE html>
<meta charset="utf-8">
<title>[WIP]UNIX痛恨者手册</title>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
<div class="container" style="min-width: 392px; max-width: 60%">
<table class="table table-striped table-bordered table-hover table-condensed">
  <tr><th colspan="3">[WIP]UNIX痛恨者手册.md</th></tr>
  <tr><td colspan="3">
    <div id="readme" class="markdown-body"><h1>UNIX痛恨者手册</h1>
<h3>第一章 UNIX——世界上第一个电脑病毒</h3>
<blockquote><p>伯克利的两项最著名的产品是UNIX和LSD (一种毒品)，我想这不是巧合</p>
</blockquote>
<p>病毒依赖于微小的个体和强大的适应性得以生存。它们并不复杂：它们没有为呼吸，新陈代谢，肌体活动等功能提供什么，只有足够的DNA或RNA以供繁衍。比如，肺炎病毒比起它们入侵的细胞要小得多，但它们在每个肺炎流行季节都能够产生新的变种，造成无数人死亡。</p>
<p>一个好病毒的特点是：</p>
<ul>
<li><p>个头小</p>
<p>病毒做的事情不多，所以不需要很大。有人认为病毒不是生物，只是一些有破坏性的酸和蛋白质。</p>
</li>
<li><p>可移植性</p>
<p>病毒经常变异，以便以不同的方式攻击不同的细胞。据说AIDS就是由猴子身上的病毒变异而成的。</p>
</li>
<li><p>耗尽寄主的资源</p>
</li>
<li><p>快速变异</p>
</li>
</ul>
<p>UNIX具有以上所有优点。在它刚诞生时，很小，功能不多，缺乏真正操作系统所需要的功能（如文件映射，告诉IO，健壮的文件系统，设备锁，合理的进程间通讯），它的移植性很好。UNIX耗尽主机的资源，没有系统管理员的时时呵护，UNIX会不断恐慌，core dump，挂起。UNIX不断变异：同一个补丁在一个版本上工作，在另一个版本上就不行。</p>
<p>UNIX是有用户界面的计算机病毒。</p>
<p>标准化那些不一致的</p>
<p>================</p>
<blockquote><p>标准的伟大之处在于它可以有很多  --- Grace Murray Hopper</p>
</blockquote>
<p>自从UNIX 80年代开始流行以来，UNIX厂商一直在努力进行UNIX标准化工作。SUN, IBM，HP和DEC在这个他们自己制造的难题上倾注了数百万美元。</p>
<p>为什么UNIX厂商不喜欢UNIX标准化?</p>
<p>许多用户受够了复杂繁多的UNIX，最终只好使用Windows，因为他们的这个UNIX无法支持那个UNIX上的应用程序。</p>
<p>如果UNIX标准化了，谁还会买SUN的机器呢</p>
<h3>第二章 欢迎新用户</h3>
<p>欢迎新用户如同用一把上了六颗子弹的左轮枪玩俄罗斯轮盘赌</p>
<p>Ken Thompson 自己设计过一辆汽车。和其他车不同，它没有速度计、汽油计，也没有那些愚蠢的指示灯讨司机的厌。如果司机犯了什么错误，仪表盘上就会出现一个大大的“？”。</p>
<p>“有经验的司机，”Thompson说，“应该知道哪儿搞错了。”</p>
<p>计算机系统的新手需要一个友好的系统。至少，一个得体的系统会这样招待自己的客人：</p>
<ul>
<li>与功能有逻辑关系的命令名</li>
<li>对危险命令的小心处理</li>
<li>一致的命令行为和命令行参数解析</li>
<li>易得和易读的在线文档</li>
<li>当命令失败时，给出可理解和有用的错误反馈</li>
</ul>
<p>在建造UNIX的过程中，从没邀请过住户。来访的都是些戴着安全帽的建筑工人，被安插在这个破木板房子的各个角落。不幸的是，不仅没有人性因素（human factors）工程师的参与，而且住户的需要就从来没有被考虑过。所以抽水马桶、中央供暖、窗户等这些方便设施在后期就很难再添加了。但是建筑师们仍然为UNIX的设计而骄傲，似乎他们并不介意在一个没有烟火探测器的屋子里睡觉。</p>
<p>在其发展的大部分历史中，UNIX只是大学和工业研究人员的研究工具。随着大批便宜工作站的出现，UNIX作为平台软件进入了新时代。这一变化大约发生在1990年，其标志就是工作站厂商把C编译器从UNIX发布中剔除出去，以降低成本满足非开发用户的需求。可见，只是最近几年中UNIX厂商才开始考虑非程序员用户的需要，开始为他们提供shell以外的图形界面。</p>
<p><strong>含糊的命令名</strong></p>
<p>UNIX新手总是对UNIX对命令的命名表示惊讶。在DOS和Mac上受的教育不足以让他们体会到cp、rm、ls这类两字母命令的简洁和优美。</p>
<p>像我们这样用过70年代早期的IO设备的人都能理解，ASR-33 Teletype这类设备的速度、可靠性，以及它的键盘是万恶之源。和今天这种基于反馈原理、只需要关闭一个微开关的键盘不同，你必须用足力气揿下Teletype的键至少半英寸，以发动一个类似自行车上用的小型发电机，在上面操作要冒指骨骨折的危险。</p>
<p>如果当时Dennis和Ken用的是Selectric而不是Teletype，可能今天我们敲的将不是”cp”和”rm”是”copy”和”remove”了。（Ken Thompson曾被问道如果他能重新设计UNIX他将做什么修改，他回答说：“我会在creat命令后加上个e。”），科技在拓宽我们的选择的同时，也能限制我们的选择，此一例也。</p>
<p>20多年过去了，还有什么理由延续这一传统呢？理由就是“历史的无可替代的力量”，历史就是那些存在的代码和教科书。如果一个厂商用remove替代了rm，那么所有UNIX教科书就不适用于这一系统了，每个使用rm的shell脚本都需要被修改。而且这也不合POSIX标准。</p>
<p>一个世纪前，打字高手由于击键过快，经常把打字键柄搅在一起，工程师设计了QWERTY键盘，于是问题得到了解决，因为没人能在这样的键盘上打得快。计算机的键盘不再有机械键柄，但QWERTY的键盘布局仍然在使用。同理，在未来的一个世纪中，我们仍然会继续使用rm。</p>
<p><strong>事故会发生</strong></p>
<p>用户十分关心自己的数据和文件。他们使用计算机来产生、分析和存储重要信息。他们相信计算机能够保护他们的重要财产。如果没有了这种信任，他们和计算机的关系就会蒙上阴影。UNIX辜负了我们的信任，它拒绝对使用危险命令的用户提供保护。比如rm就是以删除文件为目的的危险命令。</p>
<p>所有UNIX新手都有不小心无可挽回地删除重要文件的经历，即使是专家和系统管理员也遇到过。因此而每年损失的时间、精力可能价值几百万美元。这是个值得解决的问题；我们不理解为何UNIX一直拒绝解决这一问题。难道结果还不够悲惨么？</p>
<p>UNIX比其他操作系统更需要提供恢复删除功能，原因是:</p>
<ul>
<li><p>UNIX文件系统没有版本功能</p>
</li>
<li><p>自动的版本维护能保留文件的历史版本，防止新版本冲掉老版本。</p>
</li>
<li><p>UNIX程序员在错误处理方面臭名昭著</p>
<p>许多程序不检查是否所有内容都被写入了磁盘，或被写入的文件是否存在。有些程序总是删除输入文件。</p>
</li>
<li><p>UNIX shell扩展“*”，而不是其子命令</p>
<p>于是rm这样的命令就无法检查“<em>”这些危险的参数。即使是DOS也对”del </em>.<em>”有些提示。但在UNIX下，rm </em> 和rm file1 file2…是没有区别的。</p>
</li>
<li><p>删除是永久的</p>
<p>UNIX没有undelete命令。许多其他更安全的系统则只是标记被删除文件所用的块为“可被使用”，然后把它移到一个特殊目录下。如果磁盘满了，这些文件块才会被重新使用。这一技术不是什么火箭科学，Macintosh在1984年就提出了“回收站”的想法，而Tenex早在1974年就采用了这一技术。连DOS也提供了简单的undelete功能，虽然并不总有效。</p>
</li>
</ul>
<p>这四个问题互相合作，制造了无数无法恢复的重要文件。解决的方法早就存在，但UNIX“标准”版中却从来没有提供。</p>
<p>欢迎来到未来世界。</p>
<p><a href="http://zqcoder.qiniucdn.com/data/20090512131053/index.html">zqcoder.qiniucdn.com</a></p>
</div>
  </td></tr>
</table>

<link href="https://cdn.bootcss.com/github-markdown-css/2.6.0/github-markdown.min.css" rel="stylesheet">
<style>
.markdown-body {
  float: left;
  font-family: "ubuntu", "Tahoma", "Microsoft YaHei", arial,sans-serif;
}
</style>
</div>